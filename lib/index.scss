@use "sass:list" as list;
@use "sass:map" as map;
@use "generators" as generators;
@use "media" as media;
@use "normalize" as normalize;
@use "variables" as var;

//
// All the available selectors. Keep up to date with $generators in `variables.scss`.
//
$pseudo-selectors: (
  hover: ":hover",
  focus: ":focus",
  focus-within: ":focus-within",
  focus-visible: ":focus-visible",
  active: ":active",
  visited: ":visited",
  target: ":target",
  first: ":first-child",
  last: ":last-child",
  only: ":only-child",
  odd: ":nth-child(odd)",
  even: ":nth-child(even)",
  first-of-type: ":first-of-type",
  last-of-type: ":last-of-type",
  only-of-type: ":only-of-type",
  empty: ":empty",
  disabled: ":disabled",
  checked: ":checked",
  indeterminate: ":indeterminate",
  default: ":default",
  required: ":required",
  valid: ":valid",
  invalid: ":invalid",
  in-range: ":in-range",
  out-of-range: ":out-of-range",
  placeholder-shown: ":placeholder-shown",
  autofill: ":autofill",
  read-only: ":read-only",
  rtl: ":dir(rtl)",
  ltr: ":dir(ltr)",
  before: "::before",
  after: "::after",
  first-letter: "::first-letter",
  first-line: "::first-line",
  marker: "::marker",
  selection: "::selection",
  file: "::file-selector-button",
  placeholder: "::placeholder",
);

//
// Takes in any number of values and returns them each joined with the configured separator.
// Return value will always have a trailing separator so it can be prefixed to other class names.
//
@function prefix($values...) {
  $prefix: "";

  @each $value in $values {
    @if $value != null and $value != "" {
      $prefix: $prefix + $value + var.$separator;
    }
  }

  @return $prefix;
}

//
// Renders content within a dark mode media query or class depending on which is enabled.
//
@mixin dark-mode-content {
  @if var.$dark-mode == "media" {
    @include media.media-dark {
      @content;
    }
  }

  @if var.$dark-mode == "class" {
    .dark {
      @content;
    }
  }
}

//
// Loops through each pseudo selector and renders classes for the current generator if it's
// included in the configured selectors. Can be used with any number of class prefixes.
//
// For example, calling `@include pseudo-selector-content("foo", "bar")` will result in class
// names such as `.foo\:bar\:classname:selector {}`.
//
@mixin pseudo-selector-content($prefixes...) {
  @each $selector, $enabled in var.$generators {
    @if map.get($pseudo-selectors, $selector) {
      $prepend: prefix(list.append($prefixes, $selector)...);
      $append: map.get($pseudo-selectors, $selector);

      @include generators.render($enabled, $prepend, $append);
    }
  }
}

//
// Kick things off
//
@mixin render {
  @if var.$normalize {
    @include normalize.modern();
    @include normalize.custom();
  }

  @each $selectors, $enabled in var.$generators {
    @if $selectors == "base" {
      @include generators.render($enabled);
    }

    @else if $selectors == "dark" {
      @include dark-mode-content {
        @include generators.render($enabled, prefix("dark"));
        @include pseudo-selector-content("dark");
      }
    }

    @else if $selectors == "responsive" {
      @each $name, $value in var.$screens {
        @include media.media-up-to($name) {
          @include generators.render($enabled, prefix($name));
          @include pseudo-selector-content($name);

          @include dark-mode-content {
            @include generators.render($enabled, prefix($name, "dark"));
            @include pseudo-selector-content($name, "dark");
          }
        }
      }
    }

    @else if map.get($pseudo-selectors, $selectors) {
      $pseudo: map.get($pseudo-selectors, $selectors);

      @include generators.render($enabled, prefix($selectors), $pseudo);
    }
  }
}
