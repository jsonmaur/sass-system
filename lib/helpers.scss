@use "sass:color" as color;
@use "sass:list" as list;
@use "sass:map" as map;
@use "sass:meta" as meta;

//
// Check the type of a variable, while allowing an empty list in place of a map for the sake of
// simplicity. e.g. If you want to disable something in the config, you can simply use `()`
// instead of `helpers.empty-map()`.
//
@function type($expected-type, $value, $name: null) {
  $type: meta.type-of($value);
  $message: "Expected a #{$expected-type}, got a #{$type}";

  @if $name {
    $message: "Expected `#{$name}` to be a #{$expected-type}, got a #{$type}";
  }

  @if $type != $expected-type {
    @if
      $expected-type == map and
      ($type == list and list.length($value) == 0) {

      @return true;
    }

    @error $message;
  }

  @return true;
}

//
// Weird way to make an empty map (ಠ_ಠ)
//
@function empty-map() {
  @return map.remove((x: x), x);
}

//
// Removes items from the beginning of a list
//
@function list-shift($list, $count: 1) {
  $result: [];

  @for $i from $count + 1 through list.length($list) {
    $result: list.append($result, list.nth($list, $i));
  }

  @return $result;
}

//
// A helper function to merge two lists into one list. Does not remove duplicate values.
//
@function list-merge($list1, $list2) {
  $result: $list1;

  @if meta.type-of($list1) != list {
    @error "list-merge expected a list, got #{meta.type-of($list1)}";
  }
  @if meta.type-of($list2) != list {
    @error "list-merge expected a list, got #{meta.type-of($list2)}";
  }

  @each $value in $list2 {
    $result: list.append($result, $value);
  }

  @return $result;
}

//
// A helper function similar to `map.deep-merge`, but will also merge any nested lists. Items in
// the second argument list will take priority in the event of a key conflict. Lists with
// different separators or surroundings (brackets vs. parenthesis) will not be merged.
//
@function map-list-merge($map1, $map2) {
  $result: $map1;

  @each $key, $value2 in $map2 {
    $value1: map.get($result, $key);

    @if
      meta.type-of($value1) != meta.type-of($value2) or
      not map.has-key($result, $key) or
      not (meta.type-of($value1) == map and meta.type-of($value2) == map) {

      @if
        (meta.type-of($value1) == list and meta.type-of($value2) == list) and
        (list.separator($value1) == list.separator($value2)) and
        (list.is-bracketed($value1) == list.is-bracketed($value2)) {

        $result: map.merge($result, ($key: list-merge($value1, $value2)));
      } @else {
        $result: map.merge($result, ($key: $value2));
      }
    } @else {
      $result: map.merge($result, ($key: map-list-merge($value1, $value2)));
    }
  }

  @return $result;
}

//
// Takes in a list of values and returns them each joined with the configured separator.
// Return value will always have a trailing separator so it can be prefixed to other class names.
//
@function combine($values, $opts...) {
  $opts: meta.keywords($opts);
  $result: "";

  @if
    list.length($values) > 0 and
    (meta.type-of($values) == list or meta.type-of($values) == arglist)  {

    @for $i from 1 through list.length($values) {
      $value: list.nth($values, $i);

      @if $value != null and $value != "" {
        @if $i >= list.length($values) and map.get($opts, trailing) == false {
          $result: $result + $value;
        }

        @else {
          $result: $result + $value + map.get($opts, separator);
        }
      }
    }
  }

  @return $result;
}

//
// Generate darker and ligher shades of each color.
//
@function color-variants($colors) {
  @if meta.type-of($colors) != map {
    @error "Expected a map, but got a #{meta.type-of($colors)}";
  }

  @each $key, $value in $colors {
    $variants: empty-map();
    $base-class: #{$key}-500;

    @for $i from 1 through 4 { // 80%, 60%, 40%, 20%
      $class: #{$key}-#{$i}00;
      $mixed: color.mix(black, $value, $weight: 100 - ($i * 20%));
      $variants: map.set($variants, $class, $mixed);

      @if $mixed == $value {
        @warn "Color `#{$value}` is too dark, unable to generate darker shades. `.#{$class}` will be the same as `.#{$base-class}`.";
      }
    }

    $variants: map.set($variants, $base-class, $value);

    @for $i from 6 through 9 { // 30%, 50%, 70%, 90%
      $class: #{$key}-#{$i}00;
      $mixed: color.mix(white, $value, $weight: 30 + (($i - 6) * 20%));
      $variants: map.set($variants, $class, $mixed);

      @if $mixed == $value {
        @warn "Color `#{$value}` is too light, unable to generate lighter tints. `.#{$class}` will be the same as `.#{$base-class}`.";
      }
    }

    $colors: map.remove($colors, $key); // remove original color key without scale suffix
    $colors: map.merge($colors, $variants);
  }

  @return $colors;
}
